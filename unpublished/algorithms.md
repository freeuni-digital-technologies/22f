# სემინარი - ალგორითმები

[ლექციის ჩანაწერი][1]

ამ სემინარზე განვიხილავთ კომპიუტერული მეცნიერებების ცნობილ ალგორითმებს. მაგალითების კოდის გასაშვებად შეგიძლიათ გამოიყენოთ კონსოლი ან ჯავასკრიპტის კოდის გასაშვები [საიტი][2]

ზოგიერთი ალგორითმის წინ ეწერება **ფსევდოკოდი**ს მაგვარი აღწერა. ფსევდო კოდი არის ალგორითმის მუშაობის პრინციპის გადმოცემა სიტყვიერად, კონკრეტული პროგრამული ენის გარეშე


## მაქსიმუმის და მინიმუმის პოვნა
გვაქვს სია და გვჭირდება ვიპოვოთ ყველაზე დიდი/ყველაზე პატარა ელემენტი

```
max იყოს პირველი ელემენტი
ყოველ შემდეგ ელემენტზე:
	შევადაროთ ელემენტი და max
		თუ მეტია, max-ის მნიშვნელობას შევცვლით
```

```js
let myarr = [2, 41, 321, 2, 56, 64]

function max(myList) {
	let max = myList[0]
	// პრობლემა ხომ არ არის, რომ i-ს 0-დან ვიწყებთ?
	for (let i=0; i < myList.length; i++) {
		// რა შეიცვლება, თუ >= ს დავწერთ?
		if (myList[i] > max) {
			max = myList[i]
		}
	}
	return max
}

max(myarr) // დააბრუნებს max-ს
```

მინიმუმის პოვნა იქნება იმავე პრინციპით, ოღონდ `if`-ში ეწერება `myList[i] <`, `>`-ის მაგივრად (სცადე დაწერა დამოუკიდებლად)

## სიის სორტირება
სორტირების ალგორითმების კოდის ცოდნა არ არის საჭირო, მხოლოდ უნდა გესმოდეთ განსხვავება

### insertion sort
- 1. ვიწყებთ პირველი ელემენტიდან
	2. 2. ვპოულობთ მინიმალურ ელემენტს ახლანდელი ელემენტის შემდეგ
	3. 3. მინიმალურს და ახლანდელს ვუცვლით ადგილს
	4. 4. გადავდივართ მომდევნო ელემენტზე და ვიმეორებთ მე-2 ნაბიჯიდან



<details markdown="1">

<summary>კოდის ჩვენება (ეს კოდი არ არის გამოცდისთვის სავალდებულო)</summary>

```js
let myarr = [2, 41, 321, 2, 56, 64]

function insertionSort(myList) {
	for (let i = 0; i < myList.length -1;    i++) {
		swap(myList, i, findMin(myList, i + 1))
		console.log(myList)
	}
  return myList
}

/**
 * იპოვის მინიმალური ელემენტის ინდექსს
 */
function findMin(myList, index) {
	let minIndex = index
	for (let i=index; i < myList.length; i++) {
		if (myList[i] < myList[minIndex]) {
			minIndex = i
		}
	}
	return minIndex
}

function swap(myList, j, k) {
	let temp = myList[j]
	myList[j] = myList[k]
	myList[k] = temp
}

sort1(myarr)
// [2, 2, 41, 56, 64, 321]
```


</details>

### bubble sort
- 1. ვიწყებთ პირველი ელემენტიდან.
	2. 2. ვადარებთ შემდეგ ელემენტს. თუ შემდეგ ელემენტზე მეტია ახლანდელი ელემენტი, ვუცვლით ერთმანეთს ადგილს
	3. 3. გადავდივართ შემდეგ ელემენტზე და ვიმეორებთ 2-დან
- ბოლოში მისვლის შემდეგ ვბრუნდებით პირველ ელემენტზე და ვიმეორებთ 1-დან ყველა ნაბიჯს მანამ, სანამ პირველიდან ბოლო ელემენტამდე ცვლილება აღარ დაგვჭირდება.

![][image-1]

<section class="non-compulsory" markdown="1">

### სორტირების სხვა ალგორითმები
- quick sort <https://www.geeksforgeeks.org/quick-sort/>
- ალგორითმების ვიზუალური შედარება <https://www.youtube.com/watch?v=kPRA0W1kECg>


</section>

## ალგორითმების კომპლექსურობა
დავაკვირდეთ insertion და bubble sort არგუმენტებს. შეგვიძლია ვივარაუდოთ, რამდენჯერ მოგვიწევს სიაზე გადაყოლა (შედარება/შეცვლა) n-ელემენტიან სიაზე?
ორივე შემთხვევაში საშუალოდ n\*n-ჯერ. 

### კვადრატული
ამ შემთხვევაში ვამბობთ, რომ ალგორითმს აქვს **კვადრატული** კომპლექსურობა - ელემენტის ერთით გაზრდასთან ერთად საჭირო დრო ბევრად მეტჯერ იზრდება (წარმოიდგინეთ პარაბოლა). რატომ არის ეს ცუდი? 

### წრფივი
მინიმუმის და მაქსიმუმის ფუნქციებს ასეთი კოპმლექსურობა აქვთ. რამდენი ელემენტიც არის, დაახლოებით იმდენჯერ დაგვჭირდება ოპერაციების შესრულება. ეს ბევრად უკეთესია, ვიდრე კვადრატული, თუმცა როგორც წესი, პროგრამისტები ცდილობენ ალგორითმის ეფექტურობა ამაზე უკეთესიც კი იყოს.

<!-- 


### ლოგარითმული



რა იქნება იმაზე უკეთესი, რომ ყოველ ჯერზე 


# მონაცემთა სტრუქტურები
წინა მაგალითში განხილული ალგორითმები გათვლილია დაულაგებელ სიებზე.

## ორობითი ხე

<https://viterbi-web.usc.edu/~adamchik/15-121/lectures/Trees/pix/pix03.bmp>


-->



[1]:	https://drive.google.com/file/d/1oL2nqFYQwbFc5fLF-hE6Ps0DOKt_R8J1/view?usp=sharing
[2]:	https://onecompiler.com/javascript/

[image-1]:	https://miro.medium.com/max/556/0*lq-ZpDYjvYGmS7PO