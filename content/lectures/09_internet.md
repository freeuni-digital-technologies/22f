# 09. ინტერნეტი
## შესავალი
### ისტორია
1969 წელს UCLA-ის სტუდენტი ARPANET-ის ქსელში სტენფორდს [დაუკავშირდა][1].და მეორე ცდაზე მესიჯი "login" გააგზავნა. 
<!-- n -->
(რამდენი ბაიტი იქნებოდა ეს მესიჯი?)

ARPANET არის პირველი კომპიუტერული ქსელი. ამ დროს მასში ოთხი უნივერსიტეტის კომპიუტერი იყო ჩართული.
დაკავშირების შემდეგ შეეცადა სისტემაში შესულიყო, და login-ბრძანების აკრეფვისას სტენფორდის სისტემა 'დაიქრაშა'. დაახლოებით ერთ საათში მიმღები კომპიუტერის პარამეტრების შეცვლის შემდეგ მცდელობა წარმატებით დასრულდა. სურათზე ხედავთ მიმღები კომპიუტერის მსგავს მოდელს. 

### 
![][image-1] 


### მოცემულობა და შეზღუდვები
4 ცალი კომპიუტერიდან 50 მილიარდამდე:

- დღეში 8 ბაიტიდან [წამში 100 000][2] გეგაბაიტამდე
- 100 000 000 000 000-ჯერ მეტი
<!-- n -->
ანუ დღეს ერთ წამში ას ტრილიონჯერ მეტი მონაცემები გაიგზავნა, ვიდრე ინტერნეტის პირველ დღეს. დღის რიცხვს ჩვენი ტვინი კიდევ უფრო ვერ აღიქვამს (ასევე მაგდენ ნოლიანს რა ქვია, ვერ ვიხსენებ). დღეში კი კიდევ 60x60x24=86,400-ჯერ უფრო მეტი.

ერთი ინტერნეტ პაკეტი პლანეტის ერთი ბოლოდან მეორემდე 10-20 კომპიუტერს გაივლის და ამას 0.1 მილიწამსაც კი არ ანდომებს

და მნიშვნელოვანია ისიც, რომ ამ ყველა კომპიუტერს შორის სხვადასხვა კავშირია. ჯერ wifi-თ უკავშირდები შენს როუტერს, რომელიც სახლში დგას. როუტერი უკავშირდება მოდემს, რომელიც ანაწილებს ინტერნეტ კავშირს შენობაში. შეიძლება ქუჩაზე ჯერ ოპტიკური კაბელი არ არის, ანუ რაღაც მომენტში გადაერთვება ერთიდან მეორეზე. თუ ოკეანის გადაღმა გზავნით, თითქმის მთელი ევროპის პაკეტებთან ერთად იგზავნება უზარმაზარი ტრანს ატლანტიკური კაბელით.

###
![][image-2]


### მთავარი პრინციპები
<!-- n -->
როგორ არის შესაძლებელი, რომ ინტერნეტი ასეთი მასშტაბური, მრავალფეროვანი და სწრაფი იყოს? და უფრო მეტიც, ნახევარი საუკუნის წინ შექმნილი მოდელს დღეს მილიარდობით მოწყობილობა უპრობლემოდ იყენებდეს? მთავარი მიზეზი ის არის, რომ ინტერნეტისთვის საჭირო ფუნქციები დაყოფილია ერთმანეთისგან მკაცრად იზოლირებულ შრეებად, ისე, რომ სხვადასხვა პრობლემების გადაჭრებმა ერთმანეთს ხელი არ შეუშალონ/არ შეზღუდონ. ამ შრეების გაცნობის შემდეგ უკეთ გაიგებთ რაზე ვსაუბრობ. ნებისმიერი დიდი და რთული სისტემის შექმნისას აუცილებელია შემადგენელი ელემენტები რაც შეიძლება მინიმალისტური იყოს. ეს სტრატეგია ხშირად გამოიყენება კომპიუტერულ მეცნიერებებში (გაიხსენეთ დეკომპოზიცია). 

თითოეულ შრეს აქვს ორი მთავარი კომპონენტი

#### ინტერფეისი

<!-- n -->
პასუხისმგებლობა, რომლის შესრულებასაც პირდება შრე (ან სერვისი, ფუნქცია). ინტერფეისი პასუხობს კითხვას **რა** და არა **როგორ**. ინტერფეისს სრული თავისუფლება აქვს, როგორც უნდა ისე შეასრულოს ნაკისრები ვალდებულება. განსაზღვრული (რასაც უნდა დაემორჩილოს) არის მხოლოდ მოცემულობა და შედეგი. რაც უფრო პატარა და კარგად განსაზღვრულია პასუხისმგებლობა, უფრო მეტ სხვადასხვა პრობლემაზე შეგვიძლია გამოვიყენოთ ეს სერვისი. 

#### პროტოკოლი

<!-- n -->

წინასწარ შეთანხმებული პრინციპები, რომლითაც ერთი შრის ორი სუბიექტი ერთმანეთს უკავშირდება. მაგალითად, იმისთვის, რომ wifi კავშირი გვგქონდეს, გვჭირდება wifi სიგნალის გამცემი და ჩვენს კომპიუტერზე ან ტელეფონზე მისი მიმღები. Wifi-ს bluetooth-ით ვერ დავუკავშირდებით. მიუხედავად იმისა, რომ ეს ორი პროტოკოლი ერთი და იმავე პასუხისმგებლობას ასრულებს (მონაცემთა გადაცემა ერთი მოწყობილობიდან მეორეში), მათ ერთმანეთის არ ესმით.


### პრობლემები, რომლებიც უნდა გადავჭრათ
<!-- n -->
ლექციის ბოლოს, მნიშვნელოვანია იცოდეთ ინტერნეტის რომელი შრე არის პასუხისმგებელი თითოეული საკითხების მოგვარებაზე:

1. გავგზავნოთ ბიტები და ბაიტები ანალოგი სიგნალით
2. გავიგოთ ყველაზე მოკლე გზა ერთი კომპიუტერიდან მეორემდე
3. დავშალოთ მესიჯი ინტერნეტ პაკეტებად და სწორი თანმიმდევრობით ავაწყოთ
4. მივანიჭოთ მოწყობილობებს მისამართი
5. გამოვიყენოთ bandwidth
6. სხვადასხვა მედიუმის/პროვაიდერის გამოყენება კავშირისთვის
7. დაკარგული პაკეტების პოვნა/აღდგენა
8. კავშირის დაზიანების პოვნა/აღდგენა


## ინტერნეტის შრეები
## 1. Physical layer
### ციფრული და ანალოგური ინფორმაციის პრინციპები
- ანალოგი - ის, რაც ფიზიკურად არსებობს
- ციფრული - რიცხვებში კონვერტირებული ანალოგი

მათ დასაკავშირებლად გვჭირდება მოწყობილობა, რომელიც **დააკონვერტირებს** ინფორმაციას.

<!-- n -->
#### მაგალითები
![][image-3]

- სურათის გადაღება ფირზე ანალოგი ოპერაციაა, დასკანერებისას ვაკეთებთ კონვერტირებას png-ში
- ოპტიკურ კაბელში 1 და 0-ების გაგზავნა ხდება სინათლის სიმძლავრით. მაღალი სინათლე - 1, დაბალი - 0
- აუდიოს ვინილზე ჩაწერა ანალოგი ოპერაციაა, ხოლო მიკროფონით ბიტებად და ბაიტებად გარდაქმნისთვის გვჭირდება მოწყობილობა, რომელიც გადააკონვერტირებს ტალღას რიცხვებში
- wifi სიგნალი არის ფიზიკური ტალღა, wifi card კი აკონვერტირებს რიცხვსა და ტალღას შორის

<!-- n -->
### პასუხისმგებლობა
ფიზიკური შრის მოვალეობაა ციფრული სიგნალის ანალოგურში (და პირიქით) გადათარგმნა

ჩიპის გამოყენებით მიღებული ინფორმაციის წაკითხვა/ჩაწერა ისევე შეიძლება, როგორც მეხსიერებიდან - უბრალოდ 1 და 0-ების მიმდევრობას ვიღებთ.


<!-- n -->



### 
![][image-4]

### პროტოკოლები
- dsl
- Bluetooth
- ethernet/wifi
- usb
- infra red
<!-- n -->
usb განსაკუთრებით მძლავრი პროტოკოლია, დააკვირდით რამდენი სრულიად განსხვავებული მოწყობილობა იყენებს - პორტატული დრაივი, პრინტერი, MIDI.

### 
![][image-5]

<!-- n -->
ერთი პროტოკოლით ორ მოწყობილობას შორის კავშირისთვის აუცილებელია **ორივე** მოწყობილობას ქონდეს adc/dac (analog to digital/digital to analog) ბარათი. მაგალითად, თუ ლეპტოპს wifi ბარათი არ აქვს, wifi ქსელში ვერ ჩავერთვებით. თუ router-ს wifi ფუნქცია არ აქვს (და მხოლოდ შნურის შესაერთებელი აქვს), ლეპტოპზე wifi-თ ვერ დავუკავშირდებით, მხოლოდ შნურით

## 2. Data Link layer - ბმული
თუ გვჭირდება 50 მილიარდი კომპიუტერი დავაკავშიროთ, პირველი, რასაც უნდა შევაცადოთ, არის 2 კომპიუტერის დაკავშირება.

### პასუხისმგებლობები
- ფიზიკურ შრეზე დაკავშირებულ ორ მოწყობილობას შორის ინფორმაციის მიმოცვლა
- ფიზიკურ შრეზე დაკარგული ინფორმაციის აღმოჩენა/კორექტირება
- ინფორმაციის დასაწყისის და დასასრულის მონიშვნა (რომ უწყვეტად მიდიოდეს კავშირი). რამდენიმე სხვადასხვა გზავნილის დაჯგუფება (და შემდეგ განცალკევება), რომ ფიზიკური კავშირი მაქსიმალური ეფექტურობით იყოს გამოყენებული. 

<!-- ### Error Control
ფიზიკურ შრეზე დაშვებული შეცდომების გამოსწორება იმის გათვალისწინებით, თუ რომელი პროტოკოლი გამოიყენება ფიზიკურ შრეზე. wifi ტალღები ბევრად უფრო მარტივად დაზიანებადია (შესაბამისად მესიჯის ნაწილები იკარგება გზაში), ვიდრე კაბელში გამავალი ნაკადი. მათემატიკურად შესაძლებელია გადაცემისას დაფიქსირებული შეცდომების პოვნა და გამოსწორება, თუმცა ამისთვის საჭიროა მესიჯისთვის დამატებითი ინფორმაციის დართვა (იმის მიხედვით, რამდენად დიდ დაზიანებასთან გამკლავება გვსურს). თუ კავშირი სანდოა (შნური), უაზროდ გამოვიყენებდით ამ ალგორითმებს და გავზრდიდით ყველა მესიჯის ზომას.


A simple example of how this works using metadata is transmitting the word "HELLO", by encoding each letter as its position in the alphabet. Thus, the letter A is coded as 1, B as 2, and so on as shown in the table on the right. Adding up the resulting numbers yields 8 + 5 + 12 + 12 + 15 = 52, and 5 + 2 = 7 calculates the metadata. Finally, the "8 5 12 12 15 7" numbers sequence is transmitted, which the receiver will see on its end if there are no transmission errors. The receiver knows that the last number received is the error-detecting metadata and that all data before is the message, so the receiver can recalculate the above math and if the metadata matches it can be concluded that the data has been received error-free. Though, if the receiver sees something like a "7 5 12 12 15 7" sequence (first element altered by some error), it can run the check by calculating 7 + 5 + 12 + 12 + 15 = 51 and 5 + 1 = 6, and discard the received data as defective since 6 does not equal 7.
-->


## 3. Network Layer - ქსელი

<!-- n -->

რადგანაც ფიზიკური კავშირის პრობლემა მოგვარებულია, შეგვიძლია დავივიწყოთ, ქსელში რომელი ორი წყვილი რა გზითაა დაკავშირებული. აქ უბრალოდ იმაზე უნდა ვიფიქროთ, ყველაზე სწრაფი გზით როგორ მოვაგვაროთ ჩამოთვლილი პრობლემები. 

### 
![][image-6]

### პასუხისმგებლობები
- ქსელის ორ წერტილს (კომპიუტერს) შორის ყველაზე მოკლე (სწრაფი) გზის პოვნა
- ქსელის დატვირთვის გადანაწილება 

### პროტოკოლები
მხოლოდ ერთი - IP
<!-- n -->
აქამდე განხილული შრეები მხოლოდ ორი კომპიუტერის დაკავშირებას ეხება. ქსელში ბევრი კომპიუტერი შედის და ერთმა მესიჯმა რამდენიმე მათგანი უნდა გაიაროს. ამისთვის მნიშნველოვანია, რომ ყველამ იცოდეს სად გადააგზავნოს მესიჯი. ამიტომ ინტერნეტში ქსელის ერთი პროტოკოლი არსებობს - IP მისამართი, უნიკალური იდენთიფიკატორი, რომელიც ქსელში ჩართულ ყველა კომპიუტერს აქვს. 

### გზის პოვნა ორ მოწყობილობას შორის
<!-- n -->
ყველაზე მნიშვნელოვანი გზის გამოთვლაა. ყველა გადამრთველმა რომ ყველა დანარჩენთან გზა გამოთვალოს და დაიმახსოვროს, ორ პრობლემას წააწყდება:
### 
- არ ეყოფა დრო და ადგილი მეხსიერებაში 
- ეს გზა ყოველ წამს იცვლება და ასეულობით წელი რომც არ ჭირდებოდეს ამ გამოთვლას, ერთ წამში უკვე უსარგებლო იქნებოდა. 
<!-- n -->

ამიტომ იმის მაგივრად, რომ მთლიანი გზა დაიმახსოვრონ, ინტერნეტში თითოეულ გადამრთველს აქვს ცხრილი სხვა მისამართების და იმახსოვრებს მხოლოდ შემდეგ გაჩერებას ამ მისამართის (ან მისამართების ჯგუფის გზაზე). დაფიქრდი, ერთი ქალაქიდან მეორეში ქალაქში კონკრეტულ მისამართზე რომ მიდიოდე. გაგიჭირდება ვინმეს პოვნა, ვინც მთლიანი გზა დეტალურად იცის. ეს გადამრთველები ასევე პერიოდულად ამოწმებენ, რამდენად გადატვირთული არიან მათი მეზობლები და მხოლოდ ახლო გარემოზე დაკვირვების გზით ცდილობენ პაკეტთა ნაკადის განაწილებას.
### 
![][image-7] 
<!-- n -->
ზემოთა სურათის ცოდნა არაა სავალდებულო

### რატომ არის საჭირო მესიჯების დაყოფა პაკეტებად?
<!-- n -->
რაც შეეხება გზავნილის ზომას, დიდი გზავნილის პატარებად დაყოფა ნიშნავს, რომ ქსელში სხვადასხვა გზით შეძლებენ წასვლას და უფრო მალე მივა ყველა ერთად, ვიდრე ერთი მეორის დალოდებისას. კიდევ რამდენიმე სხვა მიზეზის გამო, ინტერნეტ პაკეტები საკმაოდ მცირეა და მესიჯების დიდი (მაგრამ არა ყველა) ნაწილი უნდა დაიშალოს და მიღებისას აიწყოს.

### ინტერფეისის შეზღუდვები
დაკარგული პაკეტების თავიდან გაგზავნა ორი მიზეზის გამო არ გვაწყობს:
1. მეხსიერება
2. დრო
<!-- n -->

ძალიან დიდი მეხსიერება დაჭირდება რამდენიმე მილიარდ გადამრთველს, რომ გამავალი პაკეტები შეინახონ. ასევე, დიდი ზომის მონაცემთა დისკზე შესანახად ჩაწერა/წაშლა წამში ასჯერ არც ისე სწრაფია.

ყველა გადართვა ორჯერ უფრო მეტ ხანს გაგრძელდება, რადგან შეფერხება იქნება დასტურის მოლოდინში. ამის გამო, ეს პრობლემა შემდეგი შრის მოსაგვარებელია.


## 4. ტრანსპორტი
### პასუხისმგებლობები
- პაკეტების დანომვრა, აწყობა
- დაკარგული პაკეტების აღმოჩენა და თავიდან გაგზავნა

ამ პრობლემის მოგვარების ორი მთავარი გზა (პროტოკოლი) არსებობს:

### პროტოკოლები
#### TCP
- ინფორმაციის მიმოცვლამდე კომპიუტერები ამოწმებენ კავშირს (3 way handshake)
- თითოეული ინტერნეტ პაკეტის გაგზავნის შემდეგ ელოდები დასტურს (ასევე ინტერნეტ პაკეტად გამოგზავნილ მესიჯს). 

![][image-8]
### 

![][image-9]

##### რა შემთხვევებში არის ეს პროცედურა ზედმეტი?
- ვიდეო ზარი - 2 წამის წინანდელი ნათქვამი რაში გვჭირდება?

კავშირის და ყოველი პაკეტის დასტურის გზავნა და ლოდინი დროის მხრივ ძვირი ოპერაციებია და ყოველთვის არ ღირს.

#### UDP
ინტერნეტ პაკეტს აგზავნი და წარმატებებს უსურვებ :)

თუ არ ვამოწმებთ მივიდა თუ არა, აბა საიდან იგებენ აპლიკაციები, რომ ცუდი კავშირი გვაქვს?

## 5. აპლიკაცია
კომპიუტერულ პროგრამებს ახლა ისღა დარჩენიათ, გადაწყვიტონ რომელი პროტოკოლი უნდათ - tcp თუ udp და როგორმე გაიგონ მესიჯის მიმღების IP მისამართი. სხვა ყველაფერი მათი საზრუნავი აღარაა.


[1]:	https://thisdayintechhistory.com/10/29/first-message-on-the-internet/
[2]:	https://www.internetlivestats.com/one-second/

[image-1]:	https://hsto.org/storage2/7cf/8c3/fce/7cf8c3fcef1b5abf6d8250cf1d000ff1.jpg
[image-2]:	https://mocomi.com/wp-content/uploads/2016/10/MOC_GIFO_INTERNET.gif
[image-3]:	http://1.bp.blogspot.com/-TkaDbm2JApk/Tjifggo43mI/AAAAAAAACdk/Zjnrmbuz_M8/s400/image009.jpg
[image-4]:	https://www.researchgate.net/publication/309595949/figure/fig2/AS:424332557066241@1478180173228/Digital-to-analog-modulation-14.png
[image-5]:	https://cdn-reichelt.de/bilder/web/xxl_ws/E910/DLINK_DGE528T.png
[image-6]:	https://i.gifer.com/L6dm.gif
[image-7]:	https://www.researchgate.net/publication/324776867/figure/fig2/AS:619665818656777@1524751252557/An-example-of-routing-tables-in-a-storing-mode.png
[image-8]:	https://www.researchgate.net/profile/Roberto-Bifulco-2/publication/305081696/figure/fig2/AS:643173193879554@1530355847765/3-way-handshake-3-way-handshake-and-Proxy-Early-SYN-Forwarding.png
[image-9]:	https://i.stack.imgur.com/fVsBQ.png