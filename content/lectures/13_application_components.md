# 13. აპლიკაციების კომპონენტები 

## შესავალი
### რა არის ბიბლიოთეკა
<!-- n -->
გარდა ამისა, პროგრამისთვის საჭირო კოდს ყოველთვის 0-დან არ ვწერთ, არამედ ვიყენებთ სხვების მიერ შექმნილ ფუნქციების ნაკრებს. მათ **ბიბლიოთეკა** ეწოდებათ. ბიბლიოთეკის კიდევ ერთი მაგალითია numpy, რომელიც პითონში მათემატიკური ოპერაციებისთვის გამოიყენება. პრაქტიკაში ძალიან ხშირად გვჭირდება მატრიცებისა და ვექტორების ოპერაციები (ვექტორი შეგიძლია წარმოიდგინო, როგორც რიცხვების სია). იმის მაგივრად, რომ ვექტორების გამრავლების ფორმულები თავიდან შევქმნათ, შეგვიძლია ამ ბიბლიოთეკის array ობიექტები შევქმნათ. ამის შემდეგ მიმატებისა და გამრავლების ოპერაციები მარტივად მუშაობს:

#### დემონსტრაცია პითონში 
```python
>>> import numpy
>>> a = numpy.array([20, 30, 40, 50])
>>> b = numpy.array([0, 1, 2, 3])
>>> a - b
array([20, 29, 38, 47])
```

### ბიბლიოთეკის კომპონენტები
- გვაწვდის ფუნქციებსა და ობიექტებს: `move()`, `circle()`
- იძახებს ჩვენს დაწერილ ფუნქციებს _სწორ დროს_: `start()`, `draw()`

<!-- n -->
ბიბლიოთეკა ამ საგანშიც გამოგვიყენებია: `p5.js` არის ბიბლიოთეკა, რომელიც ჯავასკრიპტში კანვასზე ფიგურების ხატვის შესაძლებლობას გვაძლევს. ხანის აკადემია სწორედ ამ ბიბლიოთეკას იყენებს იმისთვის, რომ შენი დაწერილი კოდისგან ნახატები შექმნას. `p5.js`-ის გამოყენება ისეც შეგიძლია, ფაილებში გადმოწერით. ამისთვის საკმარისია `script` თეგი ჩაამატო მისი ბმულით და html ფაილში სპეციალური ელემენტი `canvas` დაამატო. თუ გაინტერესებს, შეგიძლია ინსტრუქცია მოძებნო ვებში.

## როგორ მუშაობს ამ საგნის სამუშაო გარემო  
<!-- n -->
კურსის გამოცდილებით, ჩვენი დაწერილი კოდი _უბრალოდ მუშაობს_, ღილაკზე დაჭერით. დასაწყისში კრიტიკულია, რომ კომპლექსურობამ არ დაგაბნიოს და სწავლაზე კონცენტრირდე; მაგრამ დროა დავაკვირდეთ, რა გჭირდება რომ გააკეთო შენ თითოეულ შემთხვევაში, და რა ნაწილებს _მალავს_ სამუშაო გარემო.

### CodeHS/Khan Academy
- კოდის დაწერა
- კოდის გაშვების ღილაკი

გარემო:
- ინახავს შენს კოდს
- გამართავს ბიბლიოთეკას (კანვასი, ფუნქციები)
- უკავშირებს ბიბლიოთეკას შენს კოდთან

<!-- n -->
### Html files
- ფაილების შექმნა
- ფაილების დაკავშირება
- კოდის შენახვა
- ბრაუზერში გახსნა (გაშვება)

<!-- n -->
ამ შემთხვევაში საჭირო ნაბიჯების ბევრად მეტი ნაწილია შენი პასუხისმგებლობა: index.js ჩასმული უნდა იყოს index.html-ში, ფაილი ბრაუზერით უნდა გახსნა და ა.შ. შეგიძლია მოიფიქრო, რა ნაწილი ხდება "ჯადოსნურად"? (შენი მონაწილოების გარეშე)

### გამეორება: კოდის თარგმნა პროცესორისთვის
- კომპაილერი
- ტრანსპაილერი/ინტერპრეტატორი.

<!-- n -->
პროგრამირების ენების ლექციაში ვისწავლეთ, რომ პროგრამირების ენიდან ორობითზე თარგმნა სპეციალური პროგრამის მოვალეობაა. თუ თარგმნა წინასწარ ხდება (მომხმარებლამდე ორობითი ინსტრუქცია მიდის), ენას კომპილირებული ეწოდება. თუ მომხმარებლის კომპიუტერზე სხვა პროგრამაა პასუხისმგებელი კოდის თარგმნაზე - ინტერპრეტირებული. როგორი ენაა ჯავასკრიპტი? რომელი პროგრამაა პასუხისმგებელი მის ინტერპრეტაციაზე?

### ბრაუზერის ფუნქციები
- html ელემენტების "დახატვა" ფანჯარაში
- ჯავასკრიპტ კოდის წაკითხვა (ჯავასკრიპტის ინტერპრეტაცია)
- `document` ობიექტისა და html ელემენტების დასინქრონირება (DOM)

## კოდიდან აპლიკაციამდე
- კოდი/source code (განაწილებული ფაილებსა და მოდულებში)
- ბიბლიოთეკა/dependencies
- compiler, transpiler
- application

<!-- n -->
კოდის ფაილები, ორგანიზებულია საერთო პასუხისმგებლობის**მოდულებში**. მაგალითად, ვებ აპლიკაციას აქვს მოდული, რომელიც მონაცემთა ბაზას უკავშირდება და პასუხისმგებელია სხვადასხვა ოპერაციებზე (შენახვა, განახლება, წაშლა). როგორც წესი, ცალკე მოდულია ხოლმე ავტორიზაცია, რომელსაც რამდენიმე სხვადასხვა მოდული (მესიჯები, პოსტები) იყენებენ. ჩვენი კოდი (source code), როგორც წესი, **დამოკიდებულია** სხვა ბიბლიოთეკებზე (dependencies). ეს ორი ერთად არის _აუცილებელი_, მაგრამ არა _საკმარისი_, მუშა პროგრამისთვის. როგორც წესი, **აპლიკაციაში** მოიაზრება პროგრამა, რომელიც _გაშვებულია_, ანუ სხვადასხვა ფუნქციებს ასრულებს. იმისთვის, რომ კოდი ამუშავდეს, გვჭირდება მისი დაკომპაილება **ორობით კოდში - binary/executable**, ან მომხმარებლის/სერვერ კომპიუტერზე **გამშვები - runtime** (transpiler/interpretator) .

