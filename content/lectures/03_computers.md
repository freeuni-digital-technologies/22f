
# 03. კომპიუტერის მუშაობის პრინციპები
## ბიტები და ბაიტები
### ორობითი სისტემა

![][image-1]
---
- Bit - binary digit
- Byte - 1 word. 8 bits (შეგვიძლია 256 რიცხვის ჩატევა. 0-დან 255-მდე ან -127-დან 128მდე)

<!-- n -->
- [why use binary, binary operations][1]
- [representing numbers and letters with binary crash course cs #4][2]

### 
## კომპიუტერის ნაწილები
<!-- n -->
რა ნაწილებს გაიხსენებდი, რაც ნებისმიერ ლეპტოპს აქვს?

---- 


![][image-2]

---- 

![][image-3]


### მეხსიერება (RAM)


![][image-4]

<!-- n -->
მეხსიერებაში მონაცემთა ჩაწერის პრინციპი დიდად არ განსხვავდება უჯრიან რვეულში ჩაწერისგან.

---- 

![][image-5]
### პროცესორი
- ფუნქციები განისაზღვრება ინსტრუქციებით
- ინსტრუქცია მიეწოდება ციფრის საშუალებით

<!-- n -->
სანამ გავიგებთ როგორ მუშაობს, ჯერ გავიგოთ რას აკეთებს. პროცესორის მუშაობის პრინციპი ძალიან გავს პროგრამისას. მას აქვს წინასწარ განსაზღვრული (და ელექტრონულად ფიქსირებული) ინსტრუქციები (ფუნქციები) და ამ ინსტრუქციას შეასრულებს მისთვის მიცემულ არგუმენტებზე. საბოლოოდ ყველა პროგრამა გადაითარგმნება ამ ინსტრუქციებად (მოგვიანებით ვისწავლით როგორ). პროგრამის ინსტრუქციები, მონაცემების მსგავსად ინახება მეხსიერებაში. არ დაგვავიწყდეს, რომ პროცესორი კალკულატორივითაა - მხოლოდ რიცხვები ესმის. თავად ინსტრუქციაც რიცხვია (პროცესორის სფეციფიკაციებში განსაზღვრულია რომელ ინსტრუქციას რა რიცხვი შეესაბამება)


#### პროცესორის ინსტრუქციები - მანქანური კოდი
![][image-6]
<!-- n -->
- მეხსიერების მართვა - კონკრეტულ მისამართზე რიცხვის ჩაწერა ან ამ მისამართიდან რიცხვის წაკითხვა შემდეგი ინსტრუქციისთვის
- არითმეტიკული და ლოგიკური ოპერაციები
	+ მიმატება/გამოკლება/გამრავლება/გაყოფა
	+ ბიტური ოპერაციები
	+ რიცხვების შედარება (მეტია/ნაკლებია/ტოლია)
- control flow ოპერაციები
	+ პროგრამის სხვა ხაზზე გადახტომა, პირობით (if-ის მსგავსი) ან უპირობოდ (ფუნქციის გამოძახების მსგავსი)
	+ პროგრამის სხვა ხაზზე გადახტომა თუ პირობა სრულდება
	+ ხაზზე გადახტომა შესაძლებელია ხაზის აბსოლიტური ნომრის მითითებით ან ახლანდელ ხაზთან მიმართებაში (1 ხაზით წინ ან უკან)


???  "მანქანური კოდის მაგალითი"
	მოდი გავიგოთ, თეორიულად როგორი მანქანური კოდი შეასრულებდა კარელის მარტივ პროგრამას. ამ კოდში რამდენიმე ხაზი გამარტივებულია და არ არის სრულად სწორი, ზედმეტი დეტალების დასამალად.
	```js
	while(beepersPresent()) {
	    takeBeeper()
	}
	```
	
	```assembly
	1. call beepersPresent (გადავა და შეასრულებს ამ ფუნქციის კოდს, შემდეგ მის შედეგს შეინახავს სპეციალურ მისამართზე რომელსაც ქვია RV. თუ ბურთი არის, ამ მისამართზე ჩაიწერება 1. თუ არა, 0)
	2. bne RV, 0, +2 (თუ 0 ჩაწერა წინა ფუნქციამ, გადახტი 2 ხაზის იქით)
	3. call takeBeeper
	4. jump 1 (გადადი პირველ ხაზზე)
	```
	
	დააკვირდით, რომ ის რაც ჯავასკრიპტში 2 ხაზი იყო, მანქანურ კოდში 4 გამოვიდა. როგორც წესი კიდევ უფრო მეტად იზრდება ხოლმე. სწორედ ამიტომ არსებობს პროგრამირების სხვადასხვა ენები - ჩვენ გვინდა პროცესორის დავალებები უფრო ინტუიტიურად და გასაგებად ვწეროთ. პროგრამირების თითოეული ენა არის აბსტრაქცია მანქანური კოდის ზედა შრეზე და პროგრამისტს საშუალებას აძლევს უმნიშვნელო დეტალებზე არ იფიქროს.


---- 

![][image-7]

### გრძელვადიანი მეხსიერება (hdd/ssd)
თუ მეხსიერება გაშვებული პროგრამების კოდის და ამ პროგრამების მონაცემების შენახვისთვის არის, გრძელვადიან მეხსიერებაში ინახება ყველა პროგრამა და ფაილი (რომელიც RAM-დან პროგრამის/კომპიუტერის გამორთვისთანავე წაიშლება).


### კომპონენტების შერჩევა კომპიუტერისთვის
- desktop კომპიუტერის აწყობა
- ლეპტოპი
	- ჩვეულებრივი
	- ოპტიმიზირებული ნაწილებით და ოპერატიული სისტემით

<!-- n -->
ეს ნაწილები მოთავსებულია და ერთმანეთთან დაკავშირებულია დედაპლატაზე. დედაპლატა მორგებულია პროცესორს და აქვს სხვადასხვა ჩასადებები/კავშირები სხვა ნაწილებთან - ჩვეულებრივ ლეპტოპებზე შეგიძლია გაზარდო მეხსიერება (თუმცა იმავე ტიპის ჩასადებისთვის უნდა იყოს), გამოცვალო მყარი დისკი და ა.შ. Desktop კომპიუტერის აწყობისას კი თავად ირჩევ რომელი ნაწილი როგორი იყოს. ამ მიდგომას ბევრი პლიუსი აქვს - (1) არჩევანის თავისუფლება (2) კონკურენცია (3) შეკეთება/გაუმჯობესება

თუმცა დადებითი მხარე აქვს ალტერნატიულ აწყობასაც - როდესაც ზუსტად იცი რა ნაწილები ექნება კომპიუტერს, ოპერატიული სისტემის კოდი შეგიძლია მაქსიმალურად ოპტიმიზირებული იყოს.

ერთ-ერთი მიზეზი, რის გამოც M1 ამდენად სწრაფი და ენერგოეფექტურია სხვა ლეპტოპებთან შედარებით არის ის, რომ მეხსიერება ჩიპშივეა ინტეგრირებული და ბევრად უფრო ახლოა პროცესორთან - შედეგად სწრაფ კავშირს და ამ ლეიაუთზე ოპტიმიზირებულ კომპიუტერს ვიღებთ. 

### რომელი ნაწილი რა გავლენას ახდენს კომპიუტერზე
<!-- ნ -->
- რა თქმა უნდა, კომპიუტერის ცენტრალური ნაწილი პროცესორია და მისი სისწრაფე მნიშვნელოვანია, თუმცა ძირითადად კომპიუტერის სინელეს სხვა ნაწილები განსაზღვრავს
- თუ მეხსიერება მცირეა, ბევრ პროგრამას ვერ გახსნი ერთდროულად. ოპერატიული სისტემა მუდმივად ცდილობს გამონახოს ადგილი პროგრამების მონაცემებისთვის, მუდმივად უწევს მეხსიერებაში ამ მონაცემების მიწევ-მოწევა გამოსათავისუფლებლად - რაც თავის მხრივ დიდ დროს მოითხოვს და კომპიუტერს ანელებს
- კომპიუტერის ყველაზე "ძვირი" (რაც დიდ დროს მოითხოვს) ოპერაცია არის გრძელვადიანი მეხსიერებიდან წაკითხვა/ჩაწერა (პროგრამების/ფაილების). hdd გარდა იმისა რომ თავისთავად ნელია, რამდენიმე წელში მისი ბლოკები ზიანდება და კიდევ უფრო მეტი დრო ჭირდება. ssd უფრო და უფრო იაფი და ხელმისაწვდომი ხდება, hddის ჩანაცვლებას სულ რამდენიმე წუთი უნდა და თუ არ გაგიკეთებიათ აუცილებლად შეცვალეთ. გეგმიხვდებით, რომ თქვენი კომპიუტერი საერთოდ არ არის ნელი.

თუ ახალი ლეპტოპის ყიდვაზე ფიქრობთ, შეგიძლიათ ნახოთ [რჩევები არჩევისთვის][3]

## კითხვები მომავალი კვირისთვის
- თუ RAM გამორთვისას სუფთავდება, მაშინ როგორ შეუძლია ზოგ ოპერატიულ სისტემას/პროგრამას გახსნილი ფანჯრების დაბრუნება კომპიუტერის ჩართვისას?
- რა უშლის ხელს ერთ პროგრამას, რომ არ გადააწეროს სხვა პროგრამის მეხსიერება (კოდი ან მონაცემები)?



[1]:	https://www.youtube.com/results?search_query=binary+computerphile
[2]:	https://www.youtube.com/watch?v=1GSjbWt0c9M&list=PLH2l6uzC4UEW0s7-KewFLBC1D0l6XRfye&index=5
[3]:	/22f/ectures/03b_choosing_specs

[image-1]:	http://shortrope.com/wp-content/uploads/2015/04/Binary-Primer.png
[image-2]:	https://www.learncomputerscienceonline.com/wp-content/uploads/2020/05/Computer-Motherboard.jpg
[image-3]:	https://upload.wikimedia.org/wikipedia/commons/d/db/Swissbit_2GB_PC2-5300U-555.jpg
[image-4]:	https://arith-matic.com/notebook/img/memory/memory-addressing.jpg
[image-5]:	https://5.imimg.com/data5/GH/CM/MY-16113916/intel-processor-500x500.jpg
[image-6]:	https://i0.wp.com/www.techquintal.com/wp-content/uploads/2021/12/Advantages-and-Disadvantages-of-Assembly-Language.jpg?fit=1024%2C576&ssl=1
[image-7]:	https://www.backblaze.com/blog/wp-content/uploads/2018/03/hdd_vs_ssd_bz.png